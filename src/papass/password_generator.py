import math
from collections.abc import Sequence
from dataclasses import dataclass

from papass.random import RngBase


@dataclass
class PasswordResult:
    """Represents the result of password generation."""

    password: str
    """The generated password."""

    entropy: float
    """Estimates how secure the password is against brute-force cracking.

    The number of possible passwords which could have been generated with the same
    settings is ``2**entropy``.
    """


class PasswordGenerator:
    """Generate passwords from a list of characters using a random number generator."""

    def __init__(self, *, alphabet: Sequence[str], rng: RngBase):
        """Create a password generator.

        :param alphabet: A sequence of characters to be used in password creation.
        :param rng: The randomness source to be used to draw characters.

        The the alphabet gets deduplicated internally.
        """
        assert len(alphabet) > 0, "Alphabet must not be empty."
        assert all(
            len(c) == 1 for c in alphabet
        ), "Alphabet must be a list of characters (length 1)."

        self._alphabet = list(sorted(set(alphabet)))
        self._rng = rng

    def generate(self, length: int) -> PasswordResult:
        """Generate a random password.

        TODO: update
        The password is generated by successive applications of ``rng.choice`` to the alphabet.

        :param length: The length of the password.
        :return: A result object containing the generated password.
        """
        upper = self._base**length
        index = self._rng.randbelow(upper)
        digits = value_to_digits(index, base=self._base, length=length)

        return PasswordResult(
            password="".join(self._alphabet[d] for d in digits),
            entropy=length * self._entropy_per_char,
        )

    def _choose_char(self) -> str:
        return self._rng.choice(self._alphabet)

    @property
    def _base(self) -> int:
        return len(self._alphabet)

    @property
    def _entropy_per_char(self) -> float:
        return math.log2(self._base)


# TODO: move to utils, test, docstring
def value_to_digits(value: int, *, base: int, length: int | None = None) -> list[int]:
    assert value >= 0, "Only positive values allowed."

    result: list[int] = []

    while value:
        result.append(value % base)
        value //= base

    if length is not None:
        assert length >= len(result)
        zeros = [0] * (length - len(result))
        result.extend(zeros)

    result.reverse()
    return result
